= Functional specification

== TODO

test
Check whether the requirement for custom relationships is obsolete when using the list node type. A user can setup custom relationships using that type. (eg. relatedProducts in response json format)

== Intro

 * [Graph Model](http://gist.neo4j.org/?693a270722b01d647849)

== Verticles

Mesh consists of various [Vert.x](http://vertx.io/) verticles. Each verticle provides REST endpoints that enable CRUD operations on core entities.

== Projects

A project is the root element for a tag hierarchy. Schemas can be assigned to the project in order to allow creation of contents which use one of the assigned schemas.
 
 * ProjectVerticle
 
== Nodes

Nodes are the main structural building blocks. Nodes can be hierarchically structured. The type of a node is always defined by the assigned schema. Typical schemas for nodes are content and folder. Nodes can be tagged by any number of tags. A node must always have only a single parent node.

=== Startpage handling

Start pages of a node are denoted by a relationship between the folder node and the content node.

== Tags

Tags can be used to add nodes. Tags can not be hierarchically structured. Tags are also assigned to tag schemas. The tag schema defines the type of the tag. Typical schemas for tags are color, keyword or stage.

Tags can have i18n properties which are specified by the schema. Tags can be manipulated using the /tags endpoint.

It is not possible to create a tag using a schema that has the binary flag enabled because the binary content could not be located within the nodes tree since tags are not placed there.

=== Object Relationships

**TBD**

?? It should be possible to create arbitrary relationships between contents / tags and inbetween both. ?? 

=== Linking nodes of different languages

Following a link to a page that does not exist in the current language leads to a mediator page. The mediator page informs the user that the content is not available in the current language, but available in english, german etc.

Links CAN include the target language.

== Paging

* /nodes

Nodes have tags and children. Both can be filtered and paged individually within the node response.

== Filtering

It should be possible to add custom filters for various requests. The user should be able to filter lists.

Possible filter usecases:

 * Filter nodes by tags (include certain tags and exclude tags)
 * Filter nodes by the isContainer field
 * Filter nodes by field value
 * Filter by schema type
 * Filter by editor / creator
 * Filter by language 
 * Filter by isBinary

== Schemas 

Schemas can be created using the schemas verticle. The schema defines the type and name of each field for a tag or a content. Those types are called field schema types. You can think of a schema as a blueprint for new tags and contents.

A schemas field type can be micoschema, reference to a node or tag, string, value or boolean. 

The root Tag of a project can not be deleted.
Schemas can be manipulated using the ObjectSchemaVerticle class.
Schema updates must directly be synchronized with all affected contents.

Schema updates create an migration action log which contains all actions to schemas and field type schemas. Those actions can be used for data migrations. 

Schemas are persisted in the neo4j database and can be exported. The exported schema contains a history of migration steps and should be versioned using git next to your frontend implementation.

Schema properties have default values which are translatable.

Schemas can be setup to represent a binary content by settings a binary enabled flag. This would enable a fileupload and filename field. It is possible to restrict fileuploads by extension (via "filetypes"), set fileupload limit ("maxSize").  

== Microschemas

A microschemas is a blueprint for a content element that can be added to a content field. In this way it is similar to a schemas.
Typical examples for microschemas are image galleries, vcard boxes, text segments.
Microschemas can not be nested. Content elements that were created using microschemas can be sorted within the context of the parent content field.
The schema for the content defines field types that can be used when creating a new content. It is possible to set a whitelist of microschemas for a field type. When whitelisting microschemas it is not possible to insert a content element of an microschema type that is not allowed by the whitelist. 

== Permissions / ACL

=== Groups

Groups are used to organize users. Roles can be assigned to groups. A user in a group with roles inherits those roles and the linked permissions to those roles.

Groups are not nested.

=== Roles

Roles are used to assign permissions to objects. Roles are assigned to groups. The create permission for a group enabled the creation of roles.

Users can only assign permissions to roles to which they have access.

A special permission or the update permission of a role (yet to be determined) enables users to create / update permissions on objects.

== Verticles

 * UserVerticle
 * GroupVerticle
 * RoleVerticle

=== Webroot

The webroot verticle provides the the /webroot endpoint. This endpoint can be used to fetch objects by specifying the request path in which those objects are located. The binary data for objects which were created using a schema that was binary enabled will automatically be returned instead of the json metadata. 

== Versioning

There is NO locking of versions. Relationships are NOT versioned (tag to content etc). Versioning is done for: tag, content, file, image
Versions are individual field nodes of a language linked.

=== Content Languages

A content node groups properties of a language together

(de)--(C)--(en)

* (C) is the content node
* (de) is a german field node
* (en) is an english field node

There are NO non-i18n-properties - all properties must be translated, except id and uuid

=== Finding the latest version of a content

ALL properties are translated
there are no meta-properties that have no translation
there needs to be a way to update single properties across all languages at once
eg. binaries for images (you want to use the same image for all language variants)

Editor and revision information is part of the versioned field node

the content node always refers to the most recent field node
the system then traverses backwards until it finds the field node thats currently online based on its online_from and ondline_to date

(a)—->(b)—->(c)—->(X)—->(d)<—-(C)

* (C) is the content node
* (d) is a version prepared for future release
* (X) is the version thats currently valid and online
