= Gentics Mesh Documentation

:raml-json: ../raml/json

This documentation provides information on the structure and functionality of the Gentics Mesh server and its API endpoints.

== TL;DR

Gentics Mesh is a API-Centric CMS Server written in Java which enables you to store and retrieve JSON documents and binaries via REST.
Gentics Mesh will also provide you a lot of powerful tools build around and for those documents.

 * Document level permission system
 * Search API
 * link:graphql.html[GraphQL API]
 * Webroot API for easy integration with modern routing frameworks
 * Image Manipulation API
 * Tagging system
 * Schema system for documents
 * Clustering (in development)
 * Versioning of your documents

== link:changelog.html[Changelog]

== link:graphql.html[GraphQL]

== REST API

The link:raml[Gentics Mesh REST API] provides endpoints which enable you to invoke CRUD operations on any Gentics Mesh element.
There are many things you can do with the REST API. For example:

* You can create new users.
* You can create nodes and tag them with tags.
* Binary data can be added to nodes.
* You can find nodes which match your search parameters.

All REST API responses are only available in JSON.

The https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en[Postman] chrome extension can be used to build and invoke requests from your browser to Gentics Mesh.

=== Authentication

==== Overview

Gentics Mesh provides multiple ways of authentication:

* Authentication via login
* Authentication via API token
* No authentication - Access via anonymous user

WARNING: Sending user credentials as base64 encoded string, or as plaintext is highly insecure to be used on an open network. This method MUST not be used in scenarios other than debugging and development when the connection between server and client is trusted.

===== Authentication Configuration

Gentics Mesh uses JWT (JSON Web Token) to handle authentication. It is thus required to create a cryptograph key to sign the sign and verify the generated JWT's. 
Typically, if no keystore file has been provided, Gentics Mesh will create one on the basis of the configuration details in `mesh.yml`. If the `keystorePassword` property is omitted, a password will be generated randomly and stored in the configuration file.

It can be configured within the `mesh.yml` configuration file. 

[source,bash]
----
security:
  tokenExpirationTime: 3600
  keystorePassword: "secret"
  keystorePath: "keystore.jceks"
  algorithm: "HS256"
----

Alternatively, you can use the https://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html[Java keytool] to create a new keystore. Here is an example on how to create a keystore which contains a HMacSHA256 key:
[source,bash]
----
keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA256 -keysize 2048 -alias HS256 -keypass secret
----

After creating the keystore, you need to set the keystore password, the path to the keystore file, and the used algorithm in the `mesh.yml` configuration file.

==== JWT 

In order to be able to store and retrieve content, a Gentics Mesh user needs to authenticate (`username:password`). 

Each way will store a JWT in a cookie which is used to authenticate the user for succeeding requests. The token only lasts a certain amount of time (which can be configured in the `mesh.yml` file), so it might be necessary to refresh the token. The JWT will be automatically renewed with every request on the Gentics Mesh API. 

NOTE: Currently, all data including media assets such as images, videos, and documents are secured and need authentication to be retrieved.

==== Login

===== Basic Authentication Header
In basic authentication, when a client requests a URL that requires authentication, the server requests the client to authenticate itself by sending a `401-Not Authorized` code. The client, in return, answers with login credentials sent in the `authorization` header:

[source,bash]
----
authorization: Basic {base64_encode(username:password)}
----

In Gentics Mesh, a user can be authenticated by invoking a regular `GET` request to the `/api/v1/auth/login` end point including a basic authentication HTTP header.

Example:

[source,bash]
----
curl -v -X GET   http://localhost:8080/api/v1/auth/login   -H 'authorization: Basic YWRtaW46YWRtaW4='
----

The response will be a valid JWT as well as set a cookie with the token.

[source,bash]
----
{
  "token" : "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyVXVpZCI6IjNjYjY2YzU0MmFlMzRiMDFiNjZjNTQyYWUzY2IwMWRiIiwiaWF0IjoxNDkxNzczMDYzLCJleHAiOjE0OTE3NzY2NjN9.8iG3I0Pe1M7J43pwbsBXiBOd6p0sn9dRxO3NfazVbOk="
}
----

===== POST JSON Data
Alternatively, the user can `POST` his or her credentials to the `/api/v1/auth/login` end point in order to retrieve a token.
The JSON object must contain these fields:

* `username` The username of the user
* `password` The password of the user

If the authentication was successful, the server will respond with a JSON object containing a single property:

* `token` The token to be sent on every subsequent request.

Additionally, the token will also be provided in a cookie.

Example:
[source,bash]
----
curl -v -X POST \
  http://localhost:8080/api/v1/auth/login \
  -H 'content-type: application/json' \
  -d '{
  "username" : "admin",
  "password" : "admin"
}'
----

[source,bash]
----

*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
> POST /api/v1/auth/login HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.50.3
> Accept: */*
> content-type: application/json
> Content-Length: 50
> 
* upload completely sent off: 50 out of 50 bytes
< HTTP/1.1 200 OK
< Content-Type: application/json; charset=utf-8
< Cache-Control: no-cache
< Content-Length: 208
< Set-Cookie: mesh.token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyVXVpZCI6IjNjYjY2YzU0MmFlMzRiMDFiNjZjNTQyYWUzY2IwMWRiIiwiaWF0IjoxNDkxNzczODU0LCJleHAiOjE0OTE3Nzc0NTR9._qt3Eufi7-3jnvgQ8lfe_KwJbd5ePwx5jOFrCK9w76A=; Max-Age=3600; Expires=Sun, 9 Apr 2017 22:37:34 GMT; Path=/
< 
{
  "token" : "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyVXVpZCI6IjNjYjY2YzU0MmFlMzRiMDFiNjZjNTQyYWUzY2IwMWRiIiwiaWF0IjoxNDkxNzczODU0LCJleHAiOjE0OTE3Nzc0NTR9._qt3Eufi7-3jnvgQ8lfe_KwJbd5ePwx5jOFrCK9w76A="
* Curl_http_done: called premature == 0
* Connection #0 to host localhost left intact
}
----

All the login method will yield a JSON web token. To make this easy mesh will directly set this token within a cookie.

The JWT can be provided in two ways. By default it is passed along with a cookie value. This is useful for embedding binary image nodes directly in HTML, since the browser will automatically handle authentication on the basis of the cookie.
Alternatively, the token can be passed along within the `Authorization` header which includes the regular JWT `Bearer <Token>`, where `<Token>` is the token you received from the login/cookie.

[source,bash]
----
curl -X GET \
  http://localhost:8080/api/v1/demo/nodes \
  -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyVXVpZCI6IjNjYjY2YzU0MmFlMzRiMDFiNjZjNTQyYWUzY2IwMWRiIiwiaWF0IjoxNDkxNzY1NDEzLCJleHAiOjE0OTE3NjkwMTN9.UY8OgjiK5qyZobAWt6X1Vd1Z-zg68BeJgGZKbW4Ucj0=' \
----

==== API token

An API token can be used to authenticate an user. The API token will never expire. This is different from regular tokens which will be issued when calling `/api/v1/auth/login`. 
Leaking an API token is potentially dangerous and thus the API token should only be used in combination with a secure connection.

Typical use cases are backend implementations which constantly communicate with Gentics Mesh via a secure / local connection.

The token can be issued on a user basis via `POST /api/v1/users/:userUuid/token`.

NOTE: Creating a new API token will automatically invalidate the previously issued token.

Since the token is just a regular JWT you just need to add it to your request `Authorization` header field.

[source,bash]
----
curl -X GET \
  http://localhost:8080/api/v1/demo/nodes \
  -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyVXVpZCI6IjNjYjY2YzU0MmFlMzRiMDFiNjZjNTQyYWUzY2IwMWRiIiwiaWF0IjoxNDkxNzY1NDEzLCJleHAiOjE0OTE3NjkwMTN9.UY8OgjiK5qyZobAWt6X1Vd1Z-zg68BeJgGZKbW4Ucj0=' \
----

It is possible to manually revoke the issued token via `DELETE /api/v1/users/:userUuid/token`. Once the token is invalidated it can no longer be used for authentication.

==== Anonymous Access 

Sometimes it may be desirable to serve public content via Gentics Mesh. All Gentics Mesh instances ship with an included `anonymous` user/role/group set. 
If no authentication details are provided Gentics Mesh will automatically try to authenticate with the user `anonymous`.

You can assign `read` permissions to the `anonymous` role for all elements you want to be publicly available.

NOTE: Assigning further permissions would of course allow for other operations to be granted. 

Anonymous access can be configured in the `mesh.yml` configuration file:

[source,yaml]
----
security:
   enableAnonymousAccess: true
----

NOTE: Recreating a previously deleted `anonymous` user would automatically re-enable the feature if the configuration setting `enableAnonymousAccess` is set to `true`.

=== Encoding

Gentics Mesh expects and returns UTF-8 encoded data. Sending data in any other encoding format will result in encoding issues.

=== Headers

It is important to set the ```Content-Type: application/json``` when sending JSON data and to also set the ```Accept``` header in order to signal Gentics Mesh that your client is accepting JSON.

[source,bash]
----
Content-Type: application/json
Accept: application/json
----

A request which is not well formatted may fail. Gentics Mesh will do its best to identify the issue and return a meaningful error response in those cases.

=== Paging

The paging query parameters are `perPage` and `page` . It is important to note that ```page``` is 1-based and ```perPage``` can be set to ```0``` in order to just retrieve a count of elements.

=== File Upload

Binary data can be attached to node binary fields which have been created using a schema that lists one or more binary fields. The ```/api/v1/nodes/:uuid/binary/:fieldName``` endpoint can be used to POST binary data and thus update the stored binary field. This endpoint is accepting only ```multipart/form-data``` .
It is required to specify the `version` and `language` within the update request. This is similar to regular node update requests in which these information must be added to the JSON.


```
----------Geg2Oob
Content-Disposition: form-data; name="version"

1.0

----------Geg2Oob
Content-Disposition: form-data; name="language"

en

----------Geg2Oob
Content-Disposition: form-data; name="shohY6d"; filename="somefile.bin"
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary

fileData

----------Geg2Oob--
```


=== Examples

*Create a new node*

It is mandatory to specify the ```parentNode``` reference, ```language```  and ```schema``` field when creating a node. 
It is possible specify the schema uuid instead of the name. At least one property within the ```schema``` object must be set.

[source]
----
POST /api/v1/demo/nodes HTTP/1.1
Host: localhost:8080
Cookie: mesh.session=61ac7969-e5ad-4c28-bc0f-0869a04e4db1
Content-Type: application/json
Accept: application/json

include::examples/api/request/api/v1/\{project\}/nodes/request-body.json[]
----

*Update an existing node*

The created node can be updated via a ```PUT``` request. You may only include those field which should be updated.

[source]
----
PUT /api/v1/demo/nodes/5af8d0e077e34361b8d0e077e353619e HTTP/1.1
Host: localhost:8080
Cookie: mesh.session=61ac7969-e5ad-4c28-bc0f-0869a04e4db1
Content-Type: application/json
Accept: application/json

include::examples/api/request/api/v1/\{project\}/nodes/\{nodeUuid\}/request-body.json[]
----

*Add a tag to a node*

Tagging nodes requires just a simple ```PUT``` request.

[source]
----
PUT /api/v1/demo/nodes/5af8d0e077e34361b8d0e077e353619e/tags/ba2edcdb1234489daedcdb1234289d38 HTTP/1.1
Host: localhost:8080
Cookie: mesh.session=61ac7969-e5ad-4c28-bc0f-0869a04e4db1
Accept: application/json
----


== link:building-blocks.html[Building Blocks]

== Software Stack

[options="header"]
|======
| Component                                                    | Type                 | Version
| http://orientdb.com/[OrientDB]                               | Graph Database       | 2.2.x
| https://github.com/Syncleus/Ferma[Ferma]                     | OGM                  | 2.2.x
| https://www.elastic.co/products/elasticsearch[Elasticsearch] | Search Engine        | 2.3.x
| http://vertx.io/[Vert.x]                                     | Core Framework       | 3.4.x
| https://hazelcast.com/[Hazelcast]                            | In-Memory Data Grid  | 3.5.x
| https://google.github.io/dagger/                             | Dependency Injection | 2.6.x
|======

== Installation

There is no dedicated installation procedure for Gentics Mesh. You just http://getmesh.io/Download[download the mesh jar] file and start it using Java.

Oracle Java Runtime 1.8.0_40 or newer is required to run Gentics Mesh.

[source,bash]
----
java -jar mesh-demo-0.9.0.jar
----

=== Docker

Alternatively you can start mesh using docker via:

The https://hub.docker.com/r/gentics/mesh-demo/[mesh-demo] image contains mesh which provides the demo data and demo application.

[source,bash]
----
docker run -p 8080:8080 gentics/mesh-demo
or
docker run -v /opt/data/:/mesh/data -p 8080:8080 gentics/mesh-demo
----

The https://hub.docker.com/r/gentics/mesh/[mesh] image contains an empty Gentics Mesh server without any demo content.

[source,bash]
----
docker run -p 8080:8080 gentics/mesh
or
docker run -v /opt/data/:/mesh/data -p 8080:8080 gentics/mesh
----


=== System Requirements

 * Oracle Java Runtime (JRE) 8u60+

=== System Configuration

The max open file limit on Linux has to be raised on most Linux systems since the embedded graph database and elasticsearch server often exceed the amount of concurrent open files.

Edit _/etc/security/limits.conf_ and add these two lines:

[source,bash]
----
Mesh   soft    nofile  60000
Mesh   hard    nofile  60000
----

Edit _/etc/pam.d/su_ and uncomment or add the following line:

[source,bash]
----
session    required   pam_limits.so
----

Please note that this change may require a logout and login after it is being applied.

== Settings

The main ```mesh.yml``` configuration file contains various settings to configure the graph database and various file system paths.

[source,json]
----
include::examples/models/mesh-config.yml[]
----

[options="header"]
|======
| Configuration            | Type   | Description
| ```clusterMode```        | Flag   | The internal hazelcast in-memory data grid will be enabled if this flag is set to true.
| ```updateCheck```        | Flag   | A update check to the mesh update server will be invoked during startup if this flag is set to true.
| ```defaultPageSize```    | Number | Default page size.
| ```defaultLanguage```    | String | Default language which is used as a fallback when no language was specified.
| ```verticles```          | List   | List of vert.x java verticle classes which will be loaded during startup.
| ```tempDirectory```      | Path   | Path to the main temporary filesystem directory.
|======

=== HTTPS/SSL

To enable https you have to specify the server key and the server certificate within the configuration.

You can create a snakeoil certificate for testing purposes this way:

[source,bash]
----
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 90 -nodes
----

=== Server Options

[options="header"]
|======
| Configuration                                     | Type      | Description
| ```httpServerOptions.port```                      | Number    | Http Port number.
| ```httpServerOptions.ssl```                       | Boolean   | Enable or disable SSL support.
| ```httpServerOptions.corsAllowedOriginPattern```  | RegEx     | Regex which will validate the origin CORS header.
| ```httpServerOptions.enableCors```                | Boolean   | Enable CORS support.
| ```httpServerOptions.certPath```                  | Path      | SSL certificate path.
| ```httpServerOptions.keyPath```                   | Path      | SSL key path.
|======

=== Storage Options

By default all specified directories are relative to the current working directory.

[options="header"]
|======
| Configuration                        | Type      | Description
| ```storageOptions.directory```       | Path      | Path to the graph database storage location.
| ```storageOptions.backupDirectory``` | Path      | Backup directory.
| ```storageOptions.exportDirectory``` | Path      | Export directory.
| ```storageOptions.startServer```     | Boolean   | Flag that indicates whether the graph database server component should be started. By default only an embedded graph database is used which does not start a graph server.
| ```storageOptions.parameters```      | JSON      | Additional JSON parameters that will be passed on to the used graph database implementation.
|======

=== Upload Options

[options="header"]
|======
| Configuration                       | Type   | Description
| ```uploadOptions.byteLimit```      | Number | Upload limit in bytes.
| ```uploadOptions.directory```      | Path   | Filesystem directory for uploaded binary data.
| ```uploadOptions.tempDirectory```  | Path   | Temporary directory for uploaded binary data. Finished files will be moved to the upload directory.
|======

=== Cache Options

Gentics Mesh does not manage any cache structure but it is possible to tweak the underlying graph and elasticsearch database cache settings.

== link:features.html[Features]

== Administration UI

The Gentics Mesh Administration UI is an AngularJS single page application which uses the REST API to interface with Gentics Mesh. By default it can be reached via ```http://localhost:8080/mesh-ui/```.

=== Configuration

The mesh-ui can be configured using the mesh-ui-config.js file.

[source,json]
----
(function(window, document) {

    /**
     * Settings which can be configured per app instance, without requiring the app be re-built from
     * source.
     */
    var meshUiConfig = {
        // The URL to the Mesh API
        apiUrl: '/api/v1/',

        // The ISO-639-1 code of the default language
        defaultLanguage: 'en',
        // The ISO-639-1 codes of the available languages
        availableLanguages: ['en', 'de'],

        // Provide an array or URLs for previewing nodes, in the following format:
        //
        // ```
        // {
        //   projectName: [
        //     // label: url
        //     { somePreview: 'http://some/url' },
        //     { otherPreview: 'http://someother/url' }
        //  ]
        // }
        // ```
        // When this option is used, a "preview" button will be available
        // in the node editor pane. Click it will POST the node data to the specified URL. The node will be
        // encoded as form data under the key "node", and its value will need to be de-serialized back into JSON
        // (e.g. using JSON.parse()). The "default" key will make the URls available to all projects.
        previewUrls: {
            default: [
                { default: 'https://httpbin.org/post' }
            ]
        },

        // A microschema control is a custom form component which can be used to render a
        // specific microschema, in place of the default form generator. For full documentation, please
        // see the example in `/microschemaControls/example/exampleControl.js`
        //
        // The `microschemaControlsLocation` may point to any location on the current server or even on
        // another server. Note that if serving microschema controls from a different server or port, you
        // must take CORS into consideration and set the Access-Control-Allow-Origin headers accordingly.
        microschemaControlsLocation: '/microschemaControls',
        microschemaControls: [
            // "geolocation/geolocationControl",
            // "example/exampleControl"
        ],

        // List any plugins to be loaded and made available to the Aloha editor.
        // (For available plugins see http://www.alohaeditor.org/guides/plugins.html)
        // If left empty, the following default plugins will be used:
        //  'common/autoparagraph',
        //  'common/contenthandler',
        //  'common/format',
        //  'common/highlighteditables',
        //  'common/list',
        //  'common/paste',
        //  'common/table',
        //  'common/ui'
        // plus a custom link plugin (mesh/mesh-link) for linking to other Mesh nodes.
        alohaPlugins: [],

        // Custom settings object for the Aloha editor. If left empty, the default configuration
        // will be used.
        alohaSettings: {}
    };


    window.meshUiConfig = meshUiConfig;

})(window, document);
----

=== Preview handling

The mesh ui will provide a preview button when editing nodes. A post request to a configureable url is being dispatchen when the button will be triggered.
The post request will contain the node JSON data of the current editing state. This way a preview page can be easily rendered by custom frontend implementations.

==  JAVA REST client

You can add the following maven dependency and repository to your project to get the mesh rest client.

[source,xml]
----
…
	<dependency>
		<artifactId>mesh-rest-client</artifactId>
		<groupId>com.gentics.mesh</groupId>
		<version>${mesh.version}</version>
	</dependency>
…
	<repositories>
		<repository>
			<id>maven.gentics.com</id>
			<name>Gentics Maven Repository</name>
			<url>https://maven.gentics.com/maven2</url>
			<releases>
				<enabled>true</enabled>
			</releases>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</repository>
	</repositories>
…
----

Usage:

[source,java]
----
	MeshRestClient client = MeshRestClient.create("localhost", 8080, vertx, BASIC_AUTH);
	client.setLogin("username", "password");
	client.login().toCompletable().await();

	client.findNodes("demo", new NodeRequestParameter().setExpandAll(true).setLanguages("en")).setHandler(rh -> {
		if (rh.succeeded()) {
			NodeListResponse list = rh.result();
			for(NodeResponse nodeResponse : list.getData()) {
				System.out.println(nodeResponse.getUuid());
				System.out.println(nodeResponse.getFields().getStringField("name").getString());
			}
		} else {
			rh.cause().printStackTrace();
		}
	});
----

== License

* Gentics Mesh is published under a commercial license. http://getmesh.io/Terms[License Terms]
* https://github.com/graphql/graphiql[GraphiQL] is owned and developed by Facebook Inc.