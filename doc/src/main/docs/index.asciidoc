= Gentics Mesh Documentation

:raml-json: ../raml/json

== Gentics Mesh Documentation

This documentation provides information on the structure and functionality of the Mesh server and its API endpoints.

== TL;DR 

Mesh is a API-Centric CMS Server written in Java which enables you to store and retrieve JSON documents and binaries via REST. 
Mesh will also provide you a lot of powerful tools build around and for those documents.

 * Document level permission system
 * Search API
 * Webroot API for easy integration with modern routing frameworks
 * Image Manipulation API
 * Tagging system
 * Schema system for documents
 * Clustering (in development)
 * Versioning of your documents (in development)

== REST API

The link:raml[Mesh REST API] provides endpoints which enable you to invoke CRUD operations on any Mesh element. 
There are many things you can do with the REST API. For example:

* You can create new users.
* You can create nodes and tag them with tags.
* Binary data can be added to nodes.
* You can find nodes which match your search parameters.

All REST API responses are only available in JSON.

The https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en[Postman] chrome extension can be used to build and invoke requests from your browser to Mesh.

=== Authentication

==== Overview
Mesh currently supports 2 ways of authentication: `Basic` and `Json Web Token (JWT)`. A user can be authenticated by setting the Authentication HTTP header in a request.
Edit the mesh configuration file (`mesh.json`) to set your prefered authentication method. Here is an example:

[source,bash]
----
"authenticationOptions" : {
  "authenticationMethod": "JWT",
  "jwtAuthenticationOptions" : {
    "tokenExpirationTime" : 3600,
    "signatureSecret" : "secret",
    "keystorePath": "keystore.jceks"
  }
}
----

`authenticationOptions.authenticationMethod` can be set to either `"Basic"` or `"JWT"`.

==== Basic Auth

To use basic auth, set the `authenticationOptions.authenticationMethod` to `"Basic"`.

When using basic auth, set the http://tools.ietf.org/html/rfc1945#section-11.1[authorization header according to RFC 1945] to authorize a user. This will also create a session for this user and set a session id cookie.
For following requests, you can choose to either send the authorization header again or send the cookie back. Both ways will work to authorize the user.

For performance reasons, we recommend using the cookie whenever possible.

To destroy the session and the cookie you can call GET on the `/api/v1/auth/logout` endpoint.

==== Json Web Token (JWT)

===== Preparations

To use basic auth, set the `authenticationOptions.authenticationMethod` to `"JWT"`. You also have to set the keystore secret and the path to the keystore file. See above for an example.

Before using JWT you have to create a keystore which holds the secret to generate the signature for the token.
Currently only the HS256 algorithm is supported. You can use the java `keytool` to create a new keystore.
Here is an example on how to create a keystore:

[source,bash]
----
keytool -genseckey -keystore keystore.jceks -storetype jceks -storepass secret -keyalg HMacSHA256 -keysize 2048 -alias HS256 -keypass secret
----

After creating the keystore, set the file path of the keystore and the password to access the keystore in the `mesh.json` configuration file.

===== Usage

====== Login

To retrieve a token, call POST on the `/api/v1/auth/login` endpoint with a json object containing these fields:

* `username` The username of the user
* `password` The password of the user

If the authentication was successful, the server will respond with a json object containing a single field:

* `token` The token to be sent on every subsequent request.

====== Setting the header

To authenticate the user for other requests, set `Authorization` header to `"Bearer <Token>"`, where `<Token>` is the token you received from the login.

====== Refreshing the token

The token only lasts a certain amount of time (which can be configured in the `mesh.json` file), so it might be necessary to refresh the token. You can call GET on the `/api/v1/auth/refresh` endpoint with your still valid token to receive a new token which has a refreshed expire time.

====== Token via cookie

When calling the login endpoint via JWT, the server also sets a cookie containing the token. Sending the cookie back can be used instead of the HTTP header to authenticate a user. This is useful for embedding binary image nodes directly in HTML.


=== Encoding

Mesh expects and returns UTF-8 encoded data. Sending data in any other encoding format will result in encoding issues.

=== Headers

It is important to set the ```Content-Type: application/json``` when sending JSON data and to also set the ```Accept``` header in order to signal Mesh that your client is accepting JSON. 


[source,bash]
----
Content-Type: application/json
Accept: application/json
----

A request which is not well formatted may fail. Mesh will do its best to identify the issue and return a meaningful error response in those cases.

=== Paging

The paging query parameters are ```perPage``` and ```page```. It is important to note that ```page``` is 1-based and ```perPage``` can be set to ```0``` in order to just retrieve a count of elements.

=== File Upload

Binary data can be attached to node binary fields which have been created using a schema that lists one or more binary fields. The ```/api/v1/nodes/:uuid/languages/:languageTag/fields/:fieldName``` endpoint can be used to POST binary data and thus update the stored binary field. This endpoint is accepting only ```multipart/form-data```.

=== Examples

*Node Creation*

It is mandatory to specify the ```parentNodeUuid```, ```language```  and ```schema``` field when creating a node. It is possible specify the schema uuid instead of the name. At least one property within the ```schema``` object must be set.

[source,json]
----
POST /api/v1/demo/nodes/2f2de9297c8143e8ade9297c8193e8fc HTTP/1.1
Host: localhost:8080
Cookie: mesh.session=61ac7969-e5ad-4c28-bc0f-0869a04e4db1
Content-Type: application/json
Accept: application/json

include::{raml-json}/demo.NodeCreateRequest.json[]
----

*Node Updating*

The created node can be updated via a ```PUT``` request. You may only include those field which should be updated.

[source,json]
----
PUT /api/v1/demo/nodes/5af8d0e077e34361b8d0e077e353619e HTTP/1.1
Host: localhost:8080
Cookie: mesh.session=61ac7969-e5ad-4c28-bc0f-0869a04e4db1
Content-Type: application/json
Accept: application/json

include::{raml-json}/demo.NodeUpdateRequest.json[]
----

*Node Tagging*

Tagging nodes requires just a simple ```PUT``` request.

[source,json]
----
PUT /api/v1/demo/nodes/5af8d0e077e34361b8d0e077e353619e/tags/ba2edcdb1234489daedcdb1234289d38 HTTP/1.1
Host: localhost:8080
Cookie: mesh.session=61ac7969-e5ad-4c28-bc0f-0869a04e4db1
Accept: application/json
----

== Building blocks

Mesh provides a various building blocks which can be used in order to setup your content structure. Below are elements which can be used to create your project datastructure.

image:overview.png[]

=== Users

Users can log into Mesh in order to interact with other elements.

Endpoint: ```/api/v1/users```


[options="header"]
|======
| Property      | Description
| uuid          | Uuid of the user
| lastname      | Lastname of the user
| firstname     | Firstname of the user
| username      | Username of the user (mandatory)
| emailAddress  | Email Address of the user
| nodeReference | Node reference which can be used to store additional user data. It is also possible to expand this field using the ```expand``` query parameter.
| enabled       | Enabled flag. Disabled users can no longer log into mash. A deleted user will not be completely removed. Instead the user will just be disabled.
| groups        | List of group references of the user
| creator       | User reference of the creator
| created       | Epoch creation date 
| editor        | User reference of the last editor
| edited        | Epoch last edited date 
| rolePerms     | Role permissions on the element
| permissions   | User permissions on the element
|======


*Response Sample*

[source,json]
----
include::{raml-json}/UserResponse.example.json[]
----

=== Groups

Groups are used to organize users. Roles can be assigned to groups. A user in a group with roles inherits those roles and the permissions that are bound to those roles.
Groups can't be nested.

Endpoint: ```/api/v1/groups```

[options="header"]
|======
| Property    | Description
| uuid        | Uuid of the group
| name        | Name of the group
| roles       | List of role references (name/uuid)
| creator     | User reference of the creator
| created     | Epoch creation date 
| editor      | User reference of the last editor
| edited      | Epoch last edited date 
| rolePerms   | Role permissions on the element
| permissions | User permissions on the element
|======

*Response Sample*

[source,json]
----
include::{raml-json}/GroupResponse.example.json[]
----

=== Roles

Roles are used to assign permissions to objects. A role can be assigned to multiple groups. 
Users can only assign permissions to roles to which they have access.
Roles can't be nested.

Endpoint: ```/api/v1/roles```

[options="header"]
|======
| Property      | Description
| uuid          | Uuid of the role
| name          | Name of the role
| groups        | List of group references of the role
| creator       | User reference of the creator
| created       | Epoch creation date 
| editor        | User reference of the last editor
| edited        | Epoch last edited date 
| rolePerms     | Role permissions on the element
| permissions   | User permissions on the element
|======

*Response Sample*

[source,json]
----
include::{raml-json}/RoleResponse.example.json[]
----

=== Projects

A project is the base element your content structure which includes tagfamilies and your node tree.
Schemas can be assigned to projects in order to allow creation of nodes which use one of the assigned schemas.

Endpoint: ```/api/v1/projects```

[options="header"]
|======
| Property      | Description
| uuid          | Uuid of the project
| name          | Name of the project
| rootNodeUuid  | Uuid of the project root node
| creator       | User reference of the creator
| created       | Epoch creation date 
| editor        | User reference of the last editor
| edited        | Epoch last edited date 
| rolePerms     | Role permissions on the element
| permissions   | User permissions on the element
|======

*Response Sample*

[source,json]
----
include::{raml-json}/ProjectResponse.example.json[]
----

=== Tag Families

Tag families are base elements for tags which are bound to single project.
Tag families can't be nested.

Endpoint: ```/api/v1/:YOURPROJECT/tagfamilies```

[options="header"]
|======
| Property      | Description
| uuid          | Uuid of the tag family
| name          | Name of the tag family
| creator       | User reference of the creator
| created       | Epoch creation date 
| editor        | User reference of the last editor
| edited        | Epoch last edited date 
| rolePerms     | Role permissions on the element
| permissions   | User permissions on the element
|======


*Response Sample*

[source,json]
----
include::{raml-json}/TagFamilyResponse.example.json[]
----

=== Tags

Tags can be added to nodes. Tags can not be hierarchically structured. 

Endpoint: ```/api/v1/:YOUR_PROJECT/tagFamilies/:uuid/tags```


[options="header"]
|======
| Property      | Description
| uuid          | Uuid of the tag
| fields        | Tag fields which provide the tag name
| tagFamily     | Tag family reference of the tag
| creator       | User reference of the creator
| created       | Epoch creation date 
| editor        | User reference of the last editor
| edited        | Epoch last edited date 
| rolePerms     | Role permissions on the element
| permissions   | User permissions on the element
|======

*Response Sample*

[source,json]
----
include::{raml-json}/TagResponse.example.json[]
----

=== Nodes

Nodes are the main structural building blocks for your content. You may create different schemas to create multiple types of nodes. 
Nodes can be hierarchically structured if the schema is allowing this. The type of a node is always defined by the assigned schema. Nodes can be tagged by any number of tags.

Endpoint: ```/api/v1/:YOURPROJECT/nodes```


[options="header"]
|======
| Property                       | Description
| uuid                           | Uuid of the node
| fields                         | Node fields of the current language
| parentNode                     | Node reference to the parent node. The project basenode has no parent node.
| language                       | Language tag of the current language
| availableLanguages             | List of available languages
| languagePaths                  | Map with languages and the corresponding webroot path. Note that the field will only be added when a `resolveLinks` parameter has been specified. 
| tags                           | List of tags that were used to tag the node
| project                        | Project reference
| schema                         | Schema reference of the node
| isContainer                    | Flag that indicates that the node is a container and may contain children
| childrenInfo                   | JSON structure which contains information on the amount and type of child elements
| published                      | Published flag
| displayField                   | Key of the field that will be used to retrieve the display name value. (eg. "title" for blogpost nodes and "filename" for binary nodes)
| segmentField                   | Key of the field that will be used to build a path segment of this node. The path segments create the webroot path to the element.
| creator                        | User reference of the creator
| created                        | Epoch creation date 
| editor                         | User reference of the last editor
| edited                         | Epoch last edited date 
| rolePerms                      | Role permissions on the element
| permissions                    | User permissions on the element
|======


*Response Sample*

[source,json]
----
include::{raml-json}/NodeResponse.example.json[]
----

==== Query Parameters

[options="header",cols="2*"]
|======

| Name
| Description

| lang
| The lang query parameter can be used to retrieve a node in a particular language.

| role
| The role query parameter may be used in order to add permission information related to the specified role to the response. 
This may be useful when you are logged in as admin but you want to retrieve the editor role permissions on a given node. When used, the response will include the ```rolePerms``` property which lists the permissions for the specified role.
Endpoint: ```/api/v1/:YOURPROJECT/nodes?role=:ROLE_UUID```

| expand
| A comma separated list of fields to expand on the node. When not set various fields may only contain element references.
It is possible to expand node fields.

| expandAll
| The ```expandAll``` query parameter is a boolean flag which can be used to expand all expandable fields. 

|======

==== Creation

It is mandatory to set the ```language``` and ```parentNodeUuid``` parameter within the JSON request when sending a create request via POST to the nodes endpoint.

Depending on the used schema it may also be mandatory to add fields to the request which are flagged as mandatory.

[source,json]
----
include::{raml-json}/NodeCreateRequest.example.json[]
----

=== Schemas

A schema defines the type and name of each field for a node. You can think of a schema as a blueprint for new nodes.

Endpoint: ```/api/v1/schemas```

[source,json]
----
include::{raml-json}/SchemaResponse.example.json[]
----

==== Configuration properties

The following configuration properties may be specified:

* **`binary`** Set to `true` to mark the schema as a binary schema. This will cause a file upload input to appear 
when creating/editing a node using this schema, and also add additional binary-specific properties to the response object
of such nodes.
* **`container`** Set to `true` to indicate that this schema can contain child nodes. This will cause the response 
object for such nodes to have a `childrenInfo` property.
* **`displayField`** Used to specify which field (as defined in the "fields" list) should be considered the title for
the purpose of displaying a list of nodes. The value must be a string which corresponds to the name of one of the
schema's fields, and additionally that field must not be of type "list", "node".

==== Schema Field 

A field is defined by an object which must have the following properties:

* **`name`** A unique name to identify the field
* **`type`** The type of data to be stored in this field.

The following optional properties may be applied to any type of field:

* **`required`** If `true`, this field may not be left empty.
* **`label`** A human-readable label for the field to be used as a form label in the admin UI. If not defined, the "name" field would be used.

In addition to the above, certain types expose additional properties with which to configure the field. Such additional
properties are defined in the [Types](#types) section.

==== Schema Field Types


[options="header",cols="3*"]
|======
| Name 
| Type Key
| Description

| String
| ```string```
| A string field type may have an ```allow``` property which acts as a white list for allowed field values

| HTML
| ```html```
| A html field type does not have any special configuration settings at this point of time.

| Number
| ```number```
| A number field type has three optional config properties: "min" is the lowest permitted value, "max" is the greatest permitted
value, and "step" is the size of the permitted increment in value. For example:

| Date
| ```date```
| The date field type stores a date in a epoch date format.

| Boolean
| ```boolean```
| A boolean field type does not have any special config settings.

| Binary
| ```binary```
| The binary field type stores binary and binary related meta data (e.g: filename, sha512sum, image width and height, mimetype..). Binary fields within nodes can be updated using the fields API.

| Node
| ```node```
| A node field type must have an ```allow``` property which acts as a white list for schemas which may be used. If ```allow``` is an
empty array, any type of node may be used.

| Micronode
| ```micronode```
| A micronode field type stores a single micronode. A micronode is similar to a node but it is directly bound to the node and thus is not accessible within the project node tree structure. Typical usecases for micronodes are galleries, location boxes, vcards.

| List
| ```list```
| A list field **must** be typed via the ```listType``` property. Possible listTypes are ```node``` ```boolean``` ```string``` ```number``` ```date``` ```micronode```
|======

==== Media type whitelist for binary schemas

Binary schemas should be able to specify which media types (aka MIME type or Content-type) they may contain. This would be done by means of a whitelist which is an array of multiple regular expressions.

Since the JSON standard does not have a special regex type, it would need to be specified as a string, but would actually be converted to and interpreted as a regex by Mesh.

== Software Stack

[options="header"]
|======
| Component                                                    | Type                | Version
| http://orientdb.com/[OrientDB]                               | Graph Database      | 2.1.x 
| https://github.com/Syncleus/Ferma[Ferma]                     | OGM                 | 2.2.x
| https://www.elastic.co/products/elasticsearch[Elasticsearch] | Search Engine       | 1.7.x
| http://vertx.io/[Vert.x]                                     | Core Framework      | 3.1.x
| https://hazelcast.com/[Hazelcast]                            | In-Memory Data Grid | 3.5.x
|======

== Installation

There is no dedicated installation procedure for mesh. You just download the ```mesh-beta.jar``` file using your beta invite code and start it using java.

[source,bash]
----
java -jar mesh-beta.jar
----

=== System Requirements

 * Oracle JRE Java 8u60+

=== System Configuration

The max open file limit on linux has to be raised on most linux systems since the embedded graph database and elasticsearch server often exceed the amount of concurrent open files.

Edit _/etc/security/limits.conf_ and add these two lines:

[source,bash]
----
Mesh   soft    nofile  60000
Mesh   hard    nofile  60000
----

Edit _/etc/pam.d/su_ and uncomment or add the following line:

[source,bash]
----
session    required   pam_limits.so
----

Please note that this change may require a logout and login after it is being applied.

== Settings

The main ```mesh.json``` configuration file contains various settings to configure the graph database and various file system paths.

[source,json]
----
include::json/mesh-config.json[]
----

[options="header"]
|======
| Configuration            | Type   | Description
| ```clusterMode```        | Flag   | The internal hazelcast in-memory data grid will be enabled if this flag is set to true.
| ```updateCheck```        | Flag   | A update check to the mesh update server will be invoked during startup if this flag is set to true.
| ```defaultPageSize```    | Number | Default page size.
| ```defaultLanguage```    | String | Default language which is used as a fallback when no language was specified.
| ```verticles```          | List   | List of vert.x java verticle classes which will be loaded during startup.
| ```tempDirectory```      | Path   | Path to the main temporary filesystem directory.
|======

=== HTTPS/SSL

To enable https you have to specify the server key and the server certificate within the Mesh configuration.

You can create a snakeoil certificate for testing purposes this way:

[source,bash]
----
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 90 -nodes
----

=== Server Options

[options="header"]
|======
| Configuration                                     | Type      | Description
| ```httpServerOptions.port```                      | Number    | Http Port number
| ```httpServerOptions.ssl```                       | Boolean   | Enable or disable SSL support
| ```httpServerOptions.corsAllowedOriginPattern```  | RegEx     | Regex which will validate the origin CORS header
| ```httpServerOptions.enableCors```                | Boolean   | Enable CORS support
| ```httpServerOptions.certPath```                  | Path      | SSL certificate path
| ```httpServerOptions.keyPath```                   | Path      | SSL key path
|======

=== Storage Options

By default all specified directories are relative to the current working directory.

[options="header"]
|======
| Configuration                        | Type      | Description
| ```storageOptions.directory```       | Path      | Path to the graph database storage location.
| ```storageOptions.backupDirectory``` | Path      | Backup directory
| ```storageOptions.exportDirectory``` | Path      | Export directory
| ```storageOptions.startServer```     | Boolean   | Flag that indicated whether the graph database server component should be started. By default only an embedded graph database is used which does not start a graph server.
| ```storageOptions.parameters```      | JSON      | Additional JSON parameters that will be passed on to the used graph database implementation.
|======

=== Upload Options

[options="header"]
|======
| Configuration                      | Type   | Description
| ```uploadOptions.byteLimit```      | Number | Upload limit in bytes
| ```uploadOptions.directory```      | Path   | Filesystem directory for uploaded binary data
| ```uploadOptions.tempDirectory```  | Path   | Temporary directory for uploaded binary data. Finished files will be moved to the upload directory. 
|======

=== Cache Options

Mesh does not manage any cache structure but it is possible to tweak the underlying graph database cache settings.

== Concepts

=== Permissions

Permissions exist between roles and other elements (including other roles). Most responses within Mesh will contain a list of permissions which may indicate that CRUD operations on the returned element is restricted in a way. 

The ```/api/v1/roles/:roleUuid/permissions``` endpoint can be used to assign or revoke permissions to/from a role. This endpoint can also be used to apply recursive permissions.
It is important to note that permissions can be applied to individual elements and onto the set of elements which is identified by the endpoint name (e.g: /groups). 


For newly created objects CRUD permissions are assigned to those roles that would be able to also create the object in the first place. By this we ensure that roles that would also be able to create the object are now able to invoke CRUD on the newly created object.

Example:

* User John is assigned to Role A. Role A grants him to create a new child Node in a parent Node.
* User Mary is assigned to Role B. Role B grants her to also create a new child Node in the same parent Node.
* When John creates a new Node the permission system identifies Role B as a role that would also be able to create the object. Therefore CRUD permissions are assigned in between Role A and B and the newly created object.

==== Users
 
Recursive permission changes on ```/users``` will also affect all listed users.

[options="header"]
|======
| Element             | Permission  | Description
| ```/api/v1/users``` | Create      | New users can be created.
| ```/api/v1/users``` | Read        |  _Not used_
| ```/api/v1/users``` | Update      |  _Not used_
| ```/api/v1/users``` | Delete      |  _Not used_
|======

Recursive permission changes on ```/users/:uuid``` have no effect on referenced elements.

[options="header"]
|======
| Element                   | Permission  | Description
| ```/api/v1/users/:uuid``` | Create      | _Not used_
| ```/api/v1/users/:uuid``` | Read        | User can be read.
| ```/api/v1/users/:uuid``` | Update      | User can be updated.
| ```/api/v1/users/:uuid``` | Delete      | User can be deleted.
|======

==== Groups
 
Recursive permission changes on ```/groups``` will affect all groups.

[options="header"]
|======
| Element              | Permission  | Description
| ```/api/v1/groups``` | Create      | New roles can be created.
| ```/api/v1/groups``` | Read        |  _Not used_
| ```/api/v1/groups``` | Update      |  _Not used_
| ```/api/v1/groups``` | Delete      |  _Not used_
|======

Recursive permission changes on ```/groups/:uuid``` will also affect users of the group but not roles that are linked to the group.

[options="header"]
|======
| Element                    | Permission  | Description
| ```/api/v1/groups/:uuid``` | Create      | _Not used_
| ```/api/v1/groups/:uuid``` | Read        | Group can be read.
| ```/api/v1/groups/:uuid``` | Update      | Group can be updated.
| ```/api/v1/groups/:uuid``` | Delete      | Group can be deleted.
|======

==== Roles

[options="header"]
|======
| Element             | Permission  | Description
| ```/api/v1/roles``` | Create      | New roles can be created.
| ```/api/v1/roles``` | Read        |  _Not used_
| ```/api/v1/roles``` | Update      |  _Not used_
| ```/api/v1/roles``` | Delete      |  _Not used_
|======

Recursive permission changes on ```/roles/:uuid``` have no effect.

[options="header"]
|======
| Element            | Permission  | Description
| ```/api/v1/roles/:uuid``` | Create      | _Not used_
| ```/api/v1/roles/:uuid``` | Read        | Role can be read.
| ```/api/v1/roles/:uuid``` | Update      | Role can be updated.
| ```/api/v1/roles/:uuid``` | Delete      | Role can be deleted.
|======

==== Schemas

Recursive permission changes on ```/schemas``` will also affect schemas.

[options="header"]
|======
| Element               | Permission  | Description
| ```/api/v1/schemas``` | Create      | New schemas can be created.
| ```/api/v1/schemas``` | Read        | _Not used_
| ```/api/v1/schemas``` | Update      | _Not used_
| ```/api/v1/schemas``` | Delete      | _Not used_
|======

Recursive permission changes on ```/schemas/:uuid``` have no effect on referenced elements.

[options="header"]
|======
| Element                     | Permission  | Description
| ```/api/v1/schemas/:uuid``` | Create      | _Not used_
| ```/api/v1/schemas/:uuid``` | Read        | The schema can be read. Read permission on the schema is also needed to be able to create new nodes that are based upon the schema.
| ```/api/v1/schemas/:uuid``` | Update      | The schema can be updated.
| ```/api/v1/schemas/:uuid``` | Delete      | The schema can be deleted.
|======

==== Projects

Recursive permission changes on ```/projects``` will also affect all projects and those elements.

[options="header"]
|======
| Element                | Permission  | Description
| ```/api/v1/projects``` | Create      | Create new projects.
| ```/api/v1/projects``` | Read        | _Not used_
| ```/api/v1/projects``` | Update      | _Not used_
| ```/api/v1/projects``` | Delete      | _Not used_
|======

Recursive permission changes on ```/projects/:uuid``` will also affect schemas, tagfamilies (and tags), nodes and subnodes.

[options="header"]
|======
| Element                      | Permission  | Description
| ```/api/v1/projects/:uuid``` | Create      | _Not used_
| ```/api/v1/projects/:uuid``` | Read        | Project can be read.
| ```/api/v1/projects/:uuid``` | Update      | Project can be updated.
| ```/api/v1/projects/:uuid``` | Delete      | Project can be deleted.
|======

==== Tag Families

Recursive permission changes on ```/project/:uuid/tagFamilies``` will also all tagfamiles and those tags.

[options="header"]
|======
| Element                                 | Permission  | Description
| ```/api/v1/project/:uuid/tagFamilies``` | Create      | Create new tag families.
| ```/api/v1/project/:uuid/tagFamilies``` | Read        |  _Not used_
| ```/api/v1/project/:uuid/tagFamilies``` | Update      |  _Not used_
| ```/api/v1/project/:uuid/tagFamilies``` | Delete      |  _Not used_
|======

Recursive permission changes on ```/project/:uuid/tagFamilies/:uuid``` will also affect tags.

[options="header"]
|======
| Element                                       | Permission  | Description
| ```/api/v1/project/:uuid/tagFamilies/:uuid``` | Create      | Tags can be created within the tag family.
| ```/api/v1/project/:uuid/tagFamilies/:uuid``` | Read        | Tag family can be read.
| ```/api/v1/project/:uuid/tagFamilies/:uuid``` | Update      | Tag family can be updated.
| ```/api/v1/project/:uuid/tagFamilies/:uuid``` | Delete      | Tag family can be deleted.
|======

==== Tags

Recursive permission on ```/api/v1/projects/:uuid/tagFamilies/:uuid/tags``` changes have no effect.

[options="header"]
|======
| Element                                            | Permission  | Description
| ```/api/v1/:YOUR_PROJECT/tagFamilies/:uuid/tags``` | Create      | Create new tags.
| ```/api/v1/:YOUR_PROJECT/tagFamilies/:uuid/tags``` | Read        | _Not used_
| ```/api/v1/:YOUR_PROJECT/tagFamilies/:uuid/tags``` | Update      | _Not used_
| ```/api/v1/:YOUR_PROJECT/tagFamilies/:uuid/tags``` | Delete      | _Not used_
|======

Recursive permission changes on ```/projects/:uuid/tagFamilies/:uuid/tags/:uuid``` have no effect.

[options="header"]
|======
| Element                                | Permission  | Description
| ```/api/v1/:YOUR_PROJECT/tags/:uuid``` | Create      | _Not used_
| ```/api/v1/:YOUR_PROJECT/tags/:uuid``` | Read        | Tag can be read.
| ```/api/v1/:YOUR_PROJECT/tags/:uuid``` | Update      | Tag can be updated.
| ```/api/v1/:YOUR_PROJECT/tags/:uuid``` | Delete      | Tag can be deleted.
|======

Recursive permission changes on ```/:YOUR_PROJECT/nodes/:uuid``` will also affect children of the node.

[options="header"]
|======
| Element                           | Permission  | Description
| ```/api/v1/:YOUR_PROJECT/nodes``` | Create      |  _Not used_
| ```/api/v1/:YOUR_PROJECT/nodes``` | Read        |  _Not used_
| ```/api/v1/:YOUR_PROJECT/nodes``` | Update      |  _Not used_
| ```/api/v1/:YOUR_PROJECT/nodes``` | Delete      |  _Not used_
|======

Recursive permission changes on ```/:YOUR_PROJECT/nodes/:uuid``` will also affect children of the node.

[options="header"]
|======
| Element                                 | Permission  | Description
| ```/api/v1/:YOUR_PROJECT/nodes/:uuid``` | Create      | Create new nodes within the node
| ```/api/v1/:YOUR_PROJECT/nodes/:uuid``` | Read        | Node can be read.
| ```/api/v1/:YOUR_PROJECT/nodes/:uuid``` | Update      | Node can be updated.
| ```/api/v1/:YOUR_PROJECT/nodes/:uuid``` | Delete      | Node can be deleted.
|======

=== WebRoot

The ```/api/v1/:YOUR_PROJECT/webroot/:path``` endpoint can be used to access nodes via a regular web path instead of using uuids.

Example: ```/api/v1/demo/webroot/Vehicle%20Images/ford-gt.jpg?width=1000``` 

This makes it possible to integrate mesh with many known routing frameworks.

[options="header"]
|======
| Framework                           | Language
| http://silex.sensiolabs.org/[Silex] | PHP
| http://expressjs.com/[ExpressJS]    | JS
| http://vertx.io/[Vert.x]            | Java,JS,Ceylon
| http://lotusrb.org/[Lotus]          | Ruby
|======

A webroot path consists of multiple path segments. Each segment of the url must be URL encoded. A list of segments can be provided by a single node. The `segmentField` information from the schema is used to determine the segment field value which the node provides. Each language of the node must provide different path segment.

The `Ford GT Image` node for example provides the path segment `ford-gt.jpg` since the used schema `vehicleImage` points to the binary field `image`. The binary field contains the filename `ford-gt.jpg`.

The `segmentField` parameter within the schema is therefore used to map in between fields and the path segment.

* `ford-gt.jpg` -> ```/api/v1/demo/webroot/Vehicle%20Images/ford-gt.jpg```

The binary data will be returned if the path targets a node in which the binary `fileName` property provides the segment.
It is possible to differentiate between a mesh binary response and a normal JSON response by checking whether the `Content-Disposition` header parameter is set. The header value will only be set when binary data is returned.

The router implementation can use this in order to be able to to decide whether to handle the JSON data or whether the binary data should just be passed through to the requestor.

=== Navigations

There are two ways of generating a nested navigation response within mesh. You can either use ```/api/v1/:YOUR_PROJECT/nodes/:uuid/navigation``` or ```/api/v1/:YOUR_PROJECT/navroot/:path``` endpoints.

Each endpoint will return a navigation response which contains the nested navigation tree structure. The ```maxDepth``` parameter may be used to limit the navigation depth (default: 10).

=== Link Handling

Mesh will try to resolve any found mesh link within any text field of a node if the resolveLinks query parameter has been set to either `short`, `medium` or `full`. 

Example: ```{{mesh.link("2f2de9297c8143e8ade9297c8193e8fc", "en")}}``` will be transformed into ```/api/v1/demo/webroot/Vehicle%20Images/ford-gt.jpg``` when using the `?resolveLinks=full`

Valid Links:

* ```{{mesh.link("2f2de9297c8143e8ade9297c8193e8fc", "en")}}```
* ```{{mesh.link('2f2de9297c8143e8ade9297c8193e8fc', 'en')}}```
* ```{{mesh.link(\"2f2de9297c8143e8ade9297c8193e8fc\", \"en\")}}```
* ```{{mesh.link("2f2de9297c8143e8ade9297c8193e8fc")}}``` (Link to default language)

==== Resolver

The ```/api/v1/utilities/linkResolver``` endpoint can be used to resolve mesh links within the posted text data. This is useful when resolving links for a preview page.

=== Schema / Microschema Migration

Mesh provides a changelog like system in order to apply and keep track of schema changes. A schema change may be a single change that adds a new field to the schema or a change which updates the schema properties.

Mesh supports the following change operations:

==== Operation: addfield

[options="header"]
|======
| Properties  | Description
| after       | Name of the field after which the new field should be inserted
| field       | Name of the field that should be added
| type        | Type of the field
| listType    | Optional list type
|======


[source,json]
----
include::json/addfield.json[]
----


==== Operation: removefield

[options="header"]
|======
| Properties  | Description
| field       | Name of the field to be removed
|======

[source,json]
----
include::json/removefield.json[]
----

==== Operation: changefieldtype

[options="header"]
|======
| Properties  | Description
| field       | Name of the field to be modified
| type        | New field type
| listType    | (Only applies for lists) New list type
|======

[source,json]
----
include::json/changefieldtype.json[]
----

==== Operation: updatefield

[options="header"]
|======
| Properties       | Description
| field            | Field to be updated
| label            | New field label
|======

[source,json]
----
include::json/updatefield.json[]
----

==== Operation: updateschema

[options="header"]
|======
| Properties       | Description
| description      | New schema description
| order            | Array of strings that contains the field order 
| displayFieldname | New displayFieldname value of the schema
| segmentFieldname | New segmentFieldname value of the schema
| container        | New container flag of the schema
|======

[source,json]
----
include::json/updateschema.json[]
----

==== Operation: updatemicroschema

[options="header"]
|======
| Properties       | Description
| description      | New microschema description
|======

[source,json]
----
include::json/updatemicroschema.json[]
----

=== Description

Each change may also provide a migration script. The migration script can be used to modify nodes that were affected by the migration.

Typical usecases for migration scripts are for example dynamic field removal or even custom reformatting of field data.
It is also possible to split a single field value into values for two new fields.

The ```/api/v1/schemas/:uuid/diff``` and ```/api/v1/microschemas/:uuid/diff``` endpoints can be used to generate a list of changes by comparing the stored and posted schema.

This list of changes can be modified and posted to ```/api/v1/schemas/:uuid/changes``` for schemas or ```/api/v1/microschemas/:uuid/changes``` for microschemas.
The posted list of changes will be validated and stored when valid. A schema migration process will be stared which runs in the background.

The https://github.com/sockjs[SockJS] compliant ```/api/v1/eventbus``` endpoint can be used to register to migration specific messages.

Additionally to websocket it is possible to query mesh whether a migration is running via the ```/api/v1/admin/migrationStatus``` endpoint.

Sending a schema to ```/api/v1/schemas:uuid``` using the ```PUT``` method will conveniently combine the diff generation and invocation of the schema migration.

Please note that by default conflicting data will be removed and this action can only be avoided by specifying a custom migration script.


=== Eventbus Bridge / Websocket

The ```/api/v1/eventbus``` endpoint allows clients to access the mesh eventbus. This may be useful if you want to react on specific mesh events. 
Currently only schema migration specific events are handled via this endpoint but more will follow.

The endpoint is https://github.com/sockjs[SockJS]  compliant. It is also possible to access the websocket directly via: ```/api/v1/eventbus/websocket```.

[options="header"]
|======
| Eventname       | Description
| mesh.migration  | Receive node and micronode migration specific events
|======

=== Image Manipulation

Images can be resized by appending the image manipulation query parameters on the binary node endpoint:


Endpoint: ```/api/v1/:YOUR_PROJECT/nodes/:uuid/languages/:languageTag/fields/:fieldname?width=220```

It is also possible to use the image manipulation in combination with the webroot endpoint:

Endpoint: ```/api/v1/:YOUR_PROJECT/webroot/:path?width=220```


It is mandatory to specify all four crop parameters when cropping an image.

[options="header"]
|=====
| Parameter    | Description
| ```width```  | Target image width.
| ```height``` | Target image height.
| ```cropx```  | Crop area start x coordinate.
| ```cropy```  | Crop area start y coordinate.
| ```cropw```  | Crop area width.
| ```croph```  | Crop area height.
|=====


=== Language Fallback

Nodes are translated into different languages. Requests for nodes should contain the requested languages (as comma separated list) as query parameter:

Endpoint: ```/api/v1/:YOUR_PROJECT/nodes/:uuid?lang=en,de```

If the requested node is available in any of the languages, the response will contain the fields in that language (first language found).
Otherwise, the node will still be returned, but without fields.

==== Referenced nodes

If requested nodes contain fields of type `node` or `list of nodes`, and the fields are expanded, the expanded versions of the referenced nodes will be in the
same language as the node (if possible), otherwise the normal language fallback is done.

=== Search

Search requests are handled by the _/search endpoints_.

Elasticsearch is used in order to provide the search functionality. This way elasticsearch queries can be posted to the search endpoints.

The JSON format of stored documents within the elasticsearch differ from the JSON format that is returned via regular Mesh endpoints. Thus it is important to know the elasticsearch document format when building an elasticsearch query. Below is a list of various example documents.

==== Users

Endpoint: ```/api/v1/search/users```

[source,json]
----
include::json/user.search.json[]
----

==== Groups

Endpoint: ```/api/v1/search/groups```

[source,json]
----
include::json/group.search.json[]
----

==== Roles

Endpoint: ```/api/v1/search/roles```

[source,json]
----
include::json/role.search.json[]
----

==== Nodes

Endpoint: ```/api/v1/search/nodes```

[source,json]
----
include::json/node.search.json[]
----

*Search nodes by schema name*

Listed below is an example search query which can be posted to ```/api/v1/search/nodes``` in order to find all nodes across all projects which were created using the content schema.
The found nodes will be sorted ascending by creator.

[source,json]
----
{
  "sort" : {
     "created" : { "order" : "asc" }
  },
  "query":{
    "bool" : {
      "must" : {
        "term" : { "schema.name" : "content" }
       }
    }
  }
}
----

*Search nodes by micronode field values*

Find all nodes which have a micronode list field (vcardlist) that contain at least one micronode which contains the two string fields (firstName, lastName) with the values ("Joe", "Doe"): 

[source,json]
----
{
  "query": {
    "nested": {
      "path": "fields.vcardlist",
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "fields.vcardlist.fields.firstName": "Joe"
              }
            },
            {
              "match": {
                "fields.vcardlist.fields.lastName": "Doe"
              }
            }
          ]
        }
      }
    }
  }
}
----

==== Projects

* ```/api/v1/search/projects```

[source,json]
----
include::json/project.search.json[]
----

==== Tags

Endpoint: ```/api/v1/search/tags```

[source,json]
----
include::json/tag.search.json[]
----

==== Tag Families

Endpoint: ```/api/v1/search/tagFamilies```

[source,json]
----
include::json/tagFamily.search.json[]
----

==== Schemas

Endpoint: ```/api/v1/search/schemas```

[source,json]
----
include::json/schema.search.json[]
----

==== Microschemas

Endpoint: ```/api/v1/search/microschemas```

[source,json]
----
include::json/microschema.search.json[]
----

== Mesh Administration UI

The Mesh Administration UI is an AngularJS single page application which uses the REST API to interface with Mesh. By default it can be reached via ```http://localhost:8080/mesh-ui/```.

=== Configuration

The mesh ui can be configured using the meshConfig.json file.

[source,json]
----
(function(window, document) {

    /**
     * Settings which can be configured per app instance, without requiring the app be re-built from
     * source.
     *
     * @name meshConfig
     */
    var meshConfig = {
        // The URL to the Mesh API
        apiUrl: '/api/v1/'
    };


    window.meshConfig = meshConfig;

})(window, document);
----

=== Preview handling

The mesh ui will provide a preview button when editing nodes. A post request to a configureable url is being dispatchen when the button will be triggered. 
The post request will contain the node JSON data of the current editing state. This way a preview page can be easily rendered by custom frontend implementations.

== License

Gentics Mesh is published under a commercial license. This license can be obtained from sales@gentics.com.

