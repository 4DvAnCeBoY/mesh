= Functional specification

== Intro

 * [Graph Model](http://gist.neo4j.org/?693a270722b01d647849)

== Verticles

Mesh consists of various [Vert.x](http://vertx.io/) verticles. Each verticle provides REST endpoints that enable CRUD operations on core entities.

== Projects

A project is the root element for a tag hierarchy. Schemas can be assigned to the project in order to allow creation of contents which use one of the assigned schemas.
 
 * ProjectVerticle

== Tags

Tags are one of main structural building blocks. Tags can be hierarchically structured. The root tag of this hierarchy is always bound to a specific project. Tags can also be tagged by other tags. The hierarchically structure is mainly used to organise tags.   

Tags can have i18n properties which are specified by the schema.
Tags can be manipulated using the  TagVerticle class.

=== Startpage handling

Start pages of a tag are denoted by a relationship between the tag and the content

== Contents

Contents are similar to tags with one major exception. Contents can not be nested. This means a content does not have a parent child relationship to another content. Only tags have this kind of relationship. A content can only have one parent tag. Contents can be tagged by any number of tags.
Contents can be manipulated using the ContentVerticle class.

=== Object Relationships

**TBD**

It should be possible to create arbitrary relationships between contents / tags and inbetween both. 

=== Linking contents of different languages

Following a link to a page that does not exist in the current language leads to a mediator page. The mediator page informs the user that the content is not available in the current language, but available in english, german etc.

Links CAN include the target language.

== Paging

* /tags
* /contents

Tags have tags and children. Both can be filtered and paged individually within the tag or content response.

== Schemas 

Schemas can be created using the schemas verticle. The schema defines the type and name of each property for a tag or a content. You can think of a schema as a blueprint for new tags and contents.

A tag must only have a single parent.

The root Tag of a project can not be deleted.
Schemas can be manipulated using the ObjectSchemaVerticle class.
Schema updates must directly be synchronized with all affected contents.

== Microschemas

A microschemas is a blueprint for a content element that can be added to a content property. In this way it is similar to a schemas.
Typical examples for microschemas are image galleries, vcard boxes, text segments.
Microschemas can not be nested. Content elements that were created using microschemas can be sorted within the context of the parent content property.
The schema for the content defines property types that can be used when creating a new content. It is possible to set a whitelist of microschemas for a property type. When whitelisting microschemas it is not possible to insert a content element of an microschema type that is not allowed by the whitelist. 
A microschema can contain references to a binary contents. This is important if a microschemas is used to create a datastructure for an image gallery. 

== Permissions / ACL

=== Groups

Groups are used to organize users. Roles can be assigned to groups. A user in a group with roles inherits those roles and the linked permissions to those roles.

Groups are not nested.

=== Roles

Roles are used to assign permissions to objects. Roles are assigned to groups. The create permission for a group enabled the creation of roles.

Users can only assign permissions to roles to which they have access.

A special permission or the update permission of a role (yet to be determined) enables users to create / update permissions on objects.

=== Verticles

 * UserVerticle
 * GroupVerticle
 * RoleVerticle

== Versioning

There is NO locking of versions. Relationships are NOT versioned (tag to content etc). Versioning is done for: tag, content, file, image
Versions are individual property nodes of a language linked.

== Content Languages

A content node groups properties of a language together

(de)—-(C)—-(en)

* (C) is the content node
* (de) is a german property node
* (en) is an english property node

There are NO non-i18n-properties - all properties must be translated, except id and uuid

=== Finding the latest version of a content

ALL properties are translated
there are no meta-properties that have no translation
there needs to be a way to update single properties across all languages at once
eg. binaries for images (you want to use the same image for all language variants)

Editor and revision information is part of the versioned property node

the content node always refers to the most recent property node
the system then traverses backwards until it finds the property node thats currently online based on its online_from and ondline_to date

(a)—->(b)—->(c)—->(X)—->(d)<—-(C)

* (C) is the content node
* (d) is a version prepared for future release
* (X) is the version thats currently valid and online
