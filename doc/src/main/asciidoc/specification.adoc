= Functional specification

== Intro

 * [Graph Model](http://gist.neo4j.org/?693a270722b01d647849)

== Verticles

Mesh consists of various [Vert.x](http://vertx.io/) verticles. Each verticle provides REST endpoints that enable CRUD operations on core entities.

== Projects

A project is the root element for a tag hierarchy. Schemas can be assigned to the project in order to allow creation of contents which use one of the assigned schemas.
 
 * ProjectVerticle
 
== Nodes

Nodes are the main structural building blocks. Nodes can be hierarchically structured. The type of a node is always defined by the assigned schema. Typical schemas for nodes are content and folder. Nodes can be tagged by any number of tags. A node must always have only a single parent node.

=== Startpage handling

Start pages of a node are denoted by a relationship between the folder node and the content node.

== Tags

Tags can be used to add nodes. Tags can not be hierarchically structured. Tags are also assigned to tag schemas. The tag schema defines the type of the tag. Typical schemas for tags are color, keyword or stage.

Tags can have i18n properties which are specified by the schema. Tags can be manipulated using the /tags endpoint.

=== Object Relationships

**TBD**

?? It should be possible to create arbitrary relationships between contents / tags and inbetween both. ?? 

=== Linking nodes of different languages

Following a link to a page that does not exist in the current language leads to a mediator page. The mediator page informs the user that the content is not available in the current language, but available in english, german etc.

Links CAN include the target language.

== Paging

* /nodes

Nodes have tags and children. Both can be filtered and paged individually within the node response.

== Schemas 

Schemas can be created using the schemas verticle. The schema defines the type and name of each property for a tag or a content. Those types are called property schema types. You can think of a schema as a blueprint for new tags and contents.


A schemas property type can be micoschema, reference to a node or tag, string, value or boolean. 

The root Tag of a project can not be deleted.
Schemas can be manipulated using the ObjectSchemaVerticle class.
Schema updates must directly be synchronized with all affected contents.

Schema updates create an migration action log which contains all actions to schemas and property type schemas. Those actions can be used for data migrations. 

Schemas are persisted in the neo4j database and can be exported. The exported schema contains a history of migration steps and should be versioned using git next to your frontend implementation.

Schema properties have default values which are translatable.

== Microschemas

A microschemas is a blueprint for a content element that can be added to a content property. In this way it is similar to a schemas.
Typical examples for microschemas are image galleries, vcard boxes, text segments.
Microschemas can not be nested. Content elements that were created using microschemas can be sorted within the context of the parent content property.
The schema for the content defines property types that can be used when creating a new content. It is possible to set a whitelist of microschemas for a property type. When whitelisting microschemas it is not possible to insert a content element of an microschema type that is not allowed by the whitelist. 
A microschema can contain references to a binary contents. This is important if a microschemas is used to create a datastructure for an image gallery.
 

== Permissions / ACL

=== Groups

Groups are used to organize users. Roles can be assigned to groups. A user in a group with roles inherits those roles and the linked permissions to those roles.

Groups are not nested.

=== Roles

Roles are used to assign permissions to objects. Roles are assigned to groups. The create permission for a group enabled the creation of roles.

Users can only assign permissions to roles to which they have access.

A special permission or the update permission of a role (yet to be determined) enables users to create / update permissions on objects.

=== Verticles

 * UserVerticle
 * GroupVerticle
 * RoleVerticle

== Versioning

There is NO locking of versions. Relationships are NOT versioned (tag to content etc). Versioning is done for: tag, content, file, image
Versions are individual property nodes of a language linked.

== Content Languages

A content node groups properties of a language together

(de)—-(C)—-(en)

* (C) is the content node
* (de) is a german property node
* (en) is an english property node

There are NO non-i18n-properties - all properties must be translated, except id and uuid

=== Finding the latest version of a content

ALL properties are translated
there are no meta-properties that have no translation
there needs to be a way to update single properties across all languages at once
eg. binaries for images (you want to use the same image for all language variants)

Editor and revision information is part of the versioned property node

the content node always refers to the most recent property node
the system then traverses backwards until it finds the property node thats currently online based on its online_from and ondline_to date

(a)—->(b)—->(c)—->(X)—->(d)<—-(C)

* (C) is the content node
* (d) is a version prepared for future release
* (X) is the version thats currently valid and online
